# 周报草稿与审核流程分离设计分析

**分析日期**: 2025-01-16
**问题核心**: 草稿状态不应混入审核流程，需作为独立状态存在
**设计原则**: 清晰分离草稿编辑阶段与审核流程阶段

---

## 1. 当前设计的根本问题

### 1.1 状态混淆

**当前ApprovalStatus枚举** (`WeeklyReport.java` 第92-98行):
```java
// 审批状态枚举 (AI分析→管理员审核→完成，无草稿状态)
public enum ApprovalStatus {
    AI_ANALYZING,           // AI分析中（创建后的初始状态）
    AI_REJECTED,            // AI分析不通过
    ADMIN_REVIEWING,        // 管理员审核中 (AI通过后的状态)
    ADMIN_APPROVED,         // 管理员审核通过，最终状态
    ADMIN_REJECTED          // 管理员审核不通过
}
```

**核心问题**:
- ❌ **ApprovalStatus** 应该只描述"审核流程"的状态
- ❌ **AI_ANALYZING** 不是审核状态，而是处理状态
- ❌ **草稿** 根本不是审核状态，而是编辑状态
- ❌ 将三个不同性质的状态（编辑、处理、审核）混在一个枚举中

### 1.2 语义冲突

**现有代码的混乱语义** (`WeeklyReport.java` 第336-345行):
```java
public boolean isDraft() {
    // 由于没有DRAFT状态，周报创建后直接进入AI分析
    // 可以认为AI_ANALYZING状态类似草稿，用户仍可修改
    return approvalStatus == ApprovalStatus.AI_ANALYZING;
}

public boolean isSubmitted() {
    // 已进入审核流程（AI分析中或之后的任何状态）
    return true; // 创建后即认为已提交
}
```

**问题分析**:
- `isDraft()` 方法名暗示"是草稿"，但检查的是 `AI_ANALYZING` 状态
- `isSubmitted()` 永远返回 `true`，意味着"创建=提交"，这不符合草稿概念
- 注释承认"由于没有DRAFT状态"，说明设计本身有缺陷

---

## 2. 正确的状态分层设计

### 2.1 三层状态模型

周报应该有**三个独立的状态维度**：

#### 层次1: 编辑状态 (EditStatus) - 用户视角
```java
public enum EditStatus {
    DRAFT,              // 草稿：用户正在编辑，未提交审核
    SUBMITTED           // 已提交：用户完成编辑，进入审核流程
}
```

**用途**:
- 区分"用户还在写"和"用户写完了"
- 决定是否允许编辑和删除
- 前端显示"保存草稿"或"已提交"标签

#### 层次2: 处理状态 (ProcessingStatus) - 系统视角
```java
public enum ProcessingStatus {
    PENDING,            // 待处理：等待AI分析
    AI_PROCESSING,      // AI处理中：正在进行AI分析
    AI_COMPLETED,       // AI完成：分析完成，待审核
    AI_FAILED           // AI失败：分析出错
}
```

**用途**:
- 追踪AI分析进度
- 决定是否需要重试AI分析
- 系统监控和告警

#### 层次3: 审核状态 (ApprovalStatus) - 管理员视角
```java
public enum ApprovalStatus {
    NOT_STARTED,        // 未开始：尚未进入审核流程
    PENDING_REVIEW,     // 待审核：等待管理员审核
    APPROVED,           // 已通过：审核通过
    REJECTED            // 已拒绝：审核不通过
}
```

**用途**:
- 管理员工作流管理
- 审核历史记录
- 权限控制（只有管理员能审核）

### 2.2 状态转换关系

```
用户操作             系统状态变化

创建周报 ──────────► EditStatus = DRAFT
 │                   ProcessingStatus = PENDING (不启动)
 │                   ApprovalStatus = NOT_STARTED
 │
 │ 用户编辑修改
 │ (允许反复保存)
 │
 ▼
提交审核 ──────────► EditStatus = SUBMITTED (锁定编辑)
 │                   ProcessingStatus = AI_PROCESSING (启动AI)
 │                   ApprovalStatus = NOT_STARTED
 │
 ▼
AI分析完成 ────────► EditStatus = SUBMITTED
 │                   ProcessingStatus = AI_COMPLETED
 │                   ApprovalStatus = PENDING_REVIEW
 │
 ▼
管理员审核 ────────► EditStatus = SUBMITTED
                     ProcessingStatus = AI_COMPLETED
                     ApprovalStatus = APPROVED / REJECTED

如果被拒绝:
管理员拒绝 ────────► EditStatus = DRAFT (解锁编辑)
                     ProcessingStatus = PENDING
                     ApprovalStatus = REJECTED
                     (允许用户修改后重新提交)
```

---

## 3. 现有设计导致的具体问题

### 3.1 用户体验问题

**场景1: 用户创建未完成的周报**
```
现状:
1. 用户点击"创建周报"
2. 填写一半内容，想稍后继续
3. 点击"保存"
4. 系统立即设置 ApprovalStatus = AI_ANALYZING
5. 立即触发AI分析（见 WeeklyReportService.java 第157-166行）
6. 用户收到"AI分析置信度低"的拒绝通知

问题:
- 用户只是想保存草稿，不是提交审核
- 浪费AI分析资源
- 给用户带来困扰（"我还没写完，为什么就被拒绝了？"）
```

**场景2: 用户无法区分"草稿"和"已提交"**
```
现状:
- isSubmitted() 永远返回 true
- 前端无法区分用户是否真正提交
- 草稿列表和已提交列表无法分开

问题:
- 用户无法管理自己的草稿
- 无法批量删除草稿
- 无法看到"我有3份草稿未完成"的提示
```

### 3.2 系统架构问题

**问题1: 审核状态被污染**
```java
// ApprovalStatus 应该只包含审核相关状态
// 但现在混入了处理状态 (AI_ANALYZING)

// ❌ 错误的命名和混用
public enum ApprovalStatus {
    AI_ANALYZING,      // 这不是审核状态！这是处理状态！
    AI_REJECTED,       // 这也不是审核状态！AI不是审核人！
    ADMIN_REVIEWING,   // 这才是审核状态
    ADMIN_APPROVED,
    ADMIN_REJECTED
}
```

**问题2: 业务逻辑混乱**
```java
// WeeklyReportService.java 第157-166行
if (weeklyReport.getApprovalStatus() == WeeklyReport.ApprovalStatus.AI_ANALYZING) {
    triggerAIAnalysis(weeklyReport);
}

// ❌ 审核状态不应该决定是否触发AI分析
// ✅ 应该由 EditStatus = SUBMITTED 触发
```

**问题3: 无法正确统计和查询**
```sql
-- 管理员想查询"待我审核的周报"
SELECT * FROM weekly_reports
WHERE approval_status = 'ADMIN_REVIEWING';

-- 但实际上还有 AI_ANALYZING 和 AI_REJECTED 的周报可能也需要人工介入
-- 查询逻辑变得复杂和混乱
```

---

## 4. 正确的实体设计

### 4.1 WeeklyReport实体修改方案

```java
@Entity
@Table(name = "weekly_reports")
public class WeeklyReport {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ============= 状态字段（三层独立管理）=============

    /**
     * 编辑状态 - 用户视角
     * 决定用户是否可以编辑和删除
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "edit_status", nullable = false, length = 20)
    private EditStatus editStatus = EditStatus.DRAFT;

    /**
     * 处理状态 - 系统视角
     * 追踪AI分析进度
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "processing_status", nullable = false, length = 30)
    private ProcessingStatus processingStatus = ProcessingStatus.PENDING;

    /**
     * 审核状态 - 管理员视角
     * 管理员审核流程管理
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "approval_status", nullable = false, length = 20)
    private ApprovalStatus approvalStatus = ApprovalStatus.NOT_STARTED;

    // ============= 状态枚举定义 =============

    /**
     * 编辑状态枚举
     */
    public enum EditStatus {
        DRAFT("草稿"),
        SUBMITTED("已提交");

        private final String description;
        EditStatus(String description) {
            this.description = description;
        }
        public String getDescription() {
            return description;
        }
    }

    /**
     * 处理状态枚举
     */
    public enum ProcessingStatus {
        PENDING("待处理"),
        AI_PROCESSING("AI分析中"),
        AI_COMPLETED("AI分析完成"),
        AI_FAILED("AI分析失败");

        private final String description;
        ProcessingStatus(String description) {
            this.description = description;
        }
        public String getDescription() {
            return description;
        }
    }

    /**
     * 审核状态枚举
     */
    public enum ApprovalStatus {
        NOT_STARTED("未开始审核"),
        PENDING_REVIEW("待审核"),
        APPROVED("审核通过"),
        REJECTED("审核拒绝");

        private final String description;
        ApprovalStatus(String description) {
            this.description = description;
        }
        public String getDescription() {
            return description;
        }
    }

    // ============= 语义清晰的辅助方法 =============

    /**
     * 是否为草稿状态（用户可以编辑）
     */
    public boolean isDraft() {
        return editStatus == EditStatus.DRAFT;
    }

    /**
     * 是否已提交审核
     */
    public boolean isSubmitted() {
        return editStatus == EditStatus.SUBMITTED;
    }

    /**
     * 是否可以编辑（草稿状态或被拒绝后重新打开）
     */
    public boolean isEditable() {
        return editStatus == EditStatus.DRAFT;
    }

    /**
     * 是否正在AI处理中
     */
    public boolean isAIProcessing() {
        return processingStatus == ProcessingStatus.AI_PROCESSING;
    }

    /**
     * 是否已完成AI分析
     */
    public boolean isAICompleted() {
        return processingStatus == ProcessingStatus.AI_COMPLETED;
    }

    /**
     * 是否待管理员审核
     */
    public boolean isPendingReview() {
        return approvalStatus == ApprovalStatus.PENDING_REVIEW;
    }

    /**
     * 是否已审核通过
     */
    public boolean isApproved() {
        return approvalStatus == ApprovalStatus.APPROVED;
    }

    /**
     * 是否已被拒绝
     */
    public boolean isRejected() {
        return approvalStatus == ApprovalStatus.REJECTED;
    }

    // ============= 状态转换方法 =============

    /**
     * 提交周报进行审核
     * 只能从草稿状态提交
     */
    public void submit() {
        if (editStatus != EditStatus.DRAFT) {
            throw new IllegalStateException(
                String.format("只能提交草稿状态的周报，当前状态: %s", editStatus)
            );
        }
        this.editStatus = EditStatus.SUBMITTED;
        this.processingStatus = ProcessingStatus.AI_PROCESSING;
        this.approvalStatus = ApprovalStatus.NOT_STARTED;
    }

    /**
     * AI分析完成
     * @param confidence AI置信度
     * @param threshold 置信度阈值
     */
    public void completeAIAnalysis(double confidence, double threshold) {
        if (processingStatus != ProcessingStatus.AI_PROCESSING) {
            throw new IllegalStateException(
                String.format("只能完成AI处理中的周报，当前状态: %s", processingStatus)
            );
        }

        this.processingStatus = ProcessingStatus.AI_COMPLETED;

        // 根据置信度决定是否进入人工审核
        if (confidence >= threshold) {
            this.approvalStatus = ApprovalStatus.PENDING_REVIEW;
        } else {
            // 置信度不足，打回草稿
            this.editStatus = EditStatus.DRAFT;
            this.approvalStatus = ApprovalStatus.NOT_STARTED;
        }
    }

    /**
     * 管理员审核通过
     * @param reviewerId 审核人ID
     */
    public void adminApprove(Long reviewerId) {
        if (approvalStatus != ApprovalStatus.PENDING_REVIEW) {
            throw new IllegalStateException(
                String.format("只能审核待审核状态的周报，当前状态: %s", approvalStatus)
            );
        }
        this.approvalStatus = ApprovalStatus.APPROVED;
        this.adminReviewerId = reviewerId;
    }

    /**
     * 管理员审核拒绝
     * @param reviewerId 审核人ID
     * @param reason 拒绝原因
     */
    public void adminReject(Long reviewerId, String reason) {
        if (approvalStatus != ApprovalStatus.PENDING_REVIEW) {
            throw new IllegalStateException(
                String.format("只能审核待审核状态的周报，当前状态: %s", approvalStatus)
            );
        }
        this.approvalStatus = ApprovalStatus.REJECTED;
        this.editStatus = EditStatus.DRAFT; // 解锁编辑
        this.processingStatus = ProcessingStatus.PENDING; // 重置处理状态
        this.adminReviewerId = reviewerId;
        this.rejectionReason = reason;
    }

    /**
     * AI分析失败
     */
    public void markAIFailed() {
        this.processingStatus = ProcessingStatus.AI_FAILED;
        // AI失败后，打回草稿让用户修改
        this.editStatus = EditStatus.DRAFT;
        this.approvalStatus = ApprovalStatus.NOT_STARTED;
    }
}
```

### 4.2 数据库迁移SQL

```sql
-- V35__Separate_Draft_From_Approval_Status.sql

-- 1. 添加新的状态字段
ALTER TABLE weekly_reports
ADD COLUMN edit_status VARCHAR(20) DEFAULT 'DRAFT' COMMENT '编辑状态: DRAFT-草稿, SUBMITTED-已提交',
ADD COLUMN processing_status VARCHAR(30) DEFAULT 'PENDING' COMMENT '处理状态: PENDING-待处理, AI_PROCESSING-AI处理中, AI_COMPLETED-AI完成, AI_FAILED-AI失败';

-- 2. 数据迁移：根据旧的 approval_status 推断新状态
UPDATE weekly_reports
SET
    edit_status = CASE
        WHEN approval_status IN ('AI_ANALYZING', 'AI_REJECTED') THEN 'DRAFT'
        ELSE 'SUBMITTED'
    END,
    processing_status = CASE
        WHEN approval_status = 'AI_ANALYZING' THEN 'AI_PROCESSING'
        WHEN approval_status IN ('AI_REJECTED', 'ADMIN_REVIEWING', 'ADMIN_APPROVED', 'ADMIN_REJECTED') THEN 'AI_COMPLETED'
        ELSE 'PENDING'
    END;

-- 3. 修改 approval_status 的枚举值
-- 注意：MySQL 8.0 不支持直接修改 ENUM，需要先转为 VARCHAR，再转回 ENUM
ALTER TABLE weekly_reports
MODIFY COLUMN approval_status VARCHAR(20) NOT NULL;

UPDATE weekly_reports
SET approval_status = CASE
    WHEN approval_status = 'AI_ANALYZING' THEN 'NOT_STARTED'
    WHEN approval_status = 'AI_REJECTED' THEN 'NOT_STARTED'
    WHEN approval_status = 'ADMIN_REVIEWING' THEN 'PENDING_REVIEW'
    WHEN approval_status = 'ADMIN_APPROVED' THEN 'APPROVED'
    WHEN approval_status = 'ADMIN_REJECTED' THEN 'REJECTED'
    ELSE 'NOT_STARTED'
END;

ALTER TABLE weekly_reports
MODIFY COLUMN approval_status ENUM('NOT_STARTED', 'PENDING_REVIEW', 'APPROVED', 'REJECTED')
NOT NULL DEFAULT 'NOT_STARTED'
COMMENT '审核状态: NOT_STARTED-未开始, PENDING_REVIEW-待审核, APPROVED-已通过, REJECTED-已拒绝';

-- 4. 设置字段为非空（已有默认值）
ALTER TABLE weekly_reports
MODIFY COLUMN edit_status VARCHAR(20) NOT NULL DEFAULT 'DRAFT',
MODIFY COLUMN processing_status VARCHAR(30) NOT NULL DEFAULT 'PENDING';

-- 5. 创建索引加速查询
CREATE INDEX idx_edit_status ON weekly_reports(edit_status);
CREATE INDEX idx_processing_status ON weekly_reports(processing_status);
CREATE INDEX idx_approval_status ON weekly_reports(approval_status);

-- 6. 创建组合索引支持常见查询场景
CREATE INDEX idx_user_edit_status ON weekly_reports(user_id, edit_status);
CREATE INDEX idx_approval_processing ON weekly_reports(approval_status, processing_status);
```

---

## 5. 服务层逻辑改进

### 5.1 创建周报（保存草稿）

```java
// WeeklyReportService.java

/**
 * 创建周报草稿
 * 注意：此方法仅创建草稿，不触发任何审核流程
 */
@Transactional
public WeeklyReportResponse createDraft(WeeklyReportCreateRequest request) {
    User currentUser = getCurrentUser();
    validateCreatePermission(currentUser, request);

    WeeklyReport weeklyReport = new WeeklyReport();
    // ... 设置各种属性 ...

    // 明确设置为草稿状态
    weeklyReport.setEditStatus(WeeklyReport.EditStatus.DRAFT);
    weeklyReport.setProcessingStatus(WeeklyReport.ProcessingStatus.PENDING);
    weeklyReport.setApprovalStatus(WeeklyReport.ApprovalStatus.NOT_STARTED);

    processTaskReports(weeklyReport, request);
    WeeklyReport savedReport = weeklyReportRepository.save(weeklyReport);

    logger.info("✅ 周报草稿已创建，周报ID: {}, 用户ID: {}",
        savedReport.getId(), currentUser.getId());

    // ⚠️ 不触发AI分析
    return convertToResponse(savedReport);
}

/**
 * 更新周报草稿
 * 只能更新草稿状态的周报
 */
@Transactional
public WeeklyReportResponse updateDraft(Long reportId, WeeklyReportUpdateRequest request) {
    WeeklyReport report = weeklyReportRepository.findById(reportId)
        .orElseThrow(() -> new RuntimeException("周报不存在: " + reportId));

    // 权限检查
    User currentUser = getCurrentUser();
    if (!report.getUserId().equals(currentUser.getId())) {
        throw new RuntimeException("无权修改他人的周报");
    }

    // 状态检查：只能修改草稿
    if (!report.isDraft()) {
        throw new IllegalStateException(
            String.format("只能修改草稿状态的周报，当前状态: %s", report.getEditStatus())
        );
    }

    // 更新内容
    updateReportContent(report, request);

    WeeklyReport savedReport = weeklyReportRepository.save(report);
    logger.info("✅ 周报草稿已更新，周报ID: {}", reportId);

    return convertToResponse(savedReport);
}

/**
 * 提交周报进行审核
 * 这是触发AI分析的唯一入口
 */
@Transactional
public WeeklyReportResponse submitForReview(Long reportId) {
    WeeklyReport report = weeklyReportRepository.findById(reportId)
        .orElseThrow(() -> new RuntimeException("周报不存在: " + reportId));

    // 权限检查
    User currentUser = getCurrentUser();
    if (!report.getUserId().equals(currentUser.getId())) {
        throw new RuntimeException("无权提交他人的周报");
    }

    // 状态检查：只能提交草稿
    if (!report.isDraft()) {
        throw new IllegalStateException(
            String.format("只能提交草稿状态的周报，当前状态: %s", report.getEditStatus())
        );
    }

    // 内容完整性检查
    validateReportCompleteness(report);

    // 提交周报（状态转换）
    report.submit();
    WeeklyReport savedReport = weeklyReportRepository.save(report);

    logger.info("📤 周报已提交审核，周报ID: {}, 用户ID: {}",
        reportId, currentUser.getId());

    // 触发AI分析
    triggerAIAnalysis(savedReport);

    return convertToResponse(savedReport);
}

/**
 * 内容完整性校验
 */
private void validateReportCompleteness(WeeklyReport report) {
    List<String> errors = new ArrayList<>();

    if (report.getTitle() == null || report.getTitle().trim().isEmpty()) {
        errors.add("周报标题不能为空");
    }

    if (report.getContent() == null || report.getContent().trim().length() < 50) {
        errors.add("周报内容不能少于50字");
    }

    if (report.getTaskReports() == null || report.getTaskReports().isEmpty()) {
        errors.add("至少需要添加一项任务报告");
    }

    if (!errors.isEmpty()) {
        throw new IllegalArgumentException(
            "周报内容不完整，无法提交：" + String.join("; ", errors)
        );
    }
}
```

### 5.2 AI分析完成处理

```java
// AIAnalysisService.java

/**
 * 更新周报状态（AI分析完成后）
 */
@Transactional
public void updateWeeklyReportStatus(Long reportId, Long analysisResultId) {
    WeeklyReport report = weeklyReportRepository.findByIdForUpdate(reportId)
        .orElseThrow(() -> new RuntimeException("周报不存在: " + reportId));

    // 状态检查：必须是AI处理中
    if (report.getProcessingStatus() != WeeklyReport.ProcessingStatus.AI_PROCESSING) {
        logger.warn("⚠️ 周报状态不正确，预期: AI_PROCESSING, 实际: {}",
            report.getProcessingStatus());
        return;
    }

    AIAnalysisResult analysisResult = aiAnalysisResultRepository.findById(analysisResultId)
        .orElseThrow(() -> new RuntimeException("AI分析结果不存在"));

    double confidence = analysisResult.getConfidence() != null ?
        analysisResult.getConfidence() : 0.0;
    boolean completed = analysisResult.getStatus() == AIAnalysisResult.AnalysisStatus.COMPLETED;

    logger.info("🔍 AI分析完成，周报ID: {}, 置信度: {}, 阈值: {}",
        reportId, confidence, weeklyReportConfidenceThreshold);

    // 关联AI分析结果
    report.setAiAnalysisId(analysisResultId);

    if (completed && confidence >= weeklyReportConfidenceThreshold) {
        // AI分析通过，进入人工审核
        report.completeAIAnalysis(confidence, weeklyReportConfidenceThreshold);
        weeklyReportRepository.save(report);

        logger.info("✅ AI分析通过，进入管理员审核队列，周报ID: {}", reportId);

        // 发送通知给管理员
        weeklyReportNotificationService.handleAIAnalysisCompleted(reportId);

    } else {
        // AI分析置信度不足，打回草稿
        report.completeAIAnalysis(confidence, weeklyReportConfidenceThreshold);
        report.setRejectionReason(String.format(
            "AI分析置信度过低(%.0f%%)，低于阈值(%.0f%%)。建议完善内容后重新提交。",
            confidence * 100,
            weeklyReportConfidenceThreshold * 100
        ));
        weeklyReportRepository.save(report);

        logger.info("🚫 AI分析置信度不足，已打回草稿，周报ID: {}", reportId);

        // 发送通知给作者
        weeklyReportNotificationService.handleAIRejected(reportId, report.getRejectionReason());
    }
}
```

### 5.3 管理员审核

```java
// WeeklyReportService.java

/**
 * 管理员审核通过
 */
@Transactional
public void adminApprove(Long reportId, Long reviewerId) {
    WeeklyReport report = weeklyReportRepository.findByIdForUpdate(reportId)
        .orElseThrow(() -> new RuntimeException("周报不存在: " + reportId));

    // 权限检查
    User reviewer = userRepository.findById(reviewerId)
        .orElseThrow(() -> new RuntimeException("审核人不存在"));
    if (!reviewer.getRole().equals(User.Role.ADMIN) &&
        !reviewer.getRole().equals(User.Role.SUPER_ADMIN)) {
        throw new RuntimeException("无权审核周报");
    }

    // 状态检查
    if (!report.isPendingReview()) {
        throw new IllegalStateException(
            String.format("只能审核待审核状态的周报，当前状态: %s", report.getApprovalStatus())
        );
    }

    report.adminApprove(reviewerId);
    weeklyReportRepository.save(report);

    logger.info("✅ 管理员审核通过，周报ID: {}, 审核人ID: {}", reportId, reviewerId);

    // 发送通知给作者
    weeklyReportNotificationService.handleAdminApproved(reportId, reviewerId);
}

/**
 * 管理员审核拒绝
 */
@Transactional
public void adminReject(Long reportId, Long reviewerId, String rejectionReason) {
    WeeklyReport report = weeklyReportRepository.findByIdForUpdate(reportId)
        .orElseThrow(() -> new RuntimeException("周报不存在: " + reportId));

    // 权限检查
    User reviewer = userRepository.findById(reviewerId)
        .orElseThrow(() -> new RuntimeException("审核人不存在"));
    if (!reviewer.getRole().equals(User.Role.ADMIN) &&
        !reviewer.getRole().equals(User.Role.SUPER_ADMIN)) {
        throw new RuntimeException("无权审核周报");
    }

    // 状态检查
    if (!report.isPendingReview()) {
        throw new IllegalStateException(
            String.format("只能审核待审核状态的周报，当前状态: %s", report.getApprovalStatus())
        );
    }

    report.adminReject(reviewerId, rejectionReason);
    weeklyReportRepository.save(report);

    logger.info("🚫 管理员审核拒绝，周报ID: {}, 审核人ID: {}, 原因: {}",
        reportId, reviewerId, rejectionReason);

    // 发送通知给作者
    weeklyReportNotificationService.handleAdminRejected(reportId, rejectionReason, reviewerId);
}
```

---

## 6. Controller接口设计

### 6.1 RESTful接口规划

```java
// WeeklyReportController.java

/**
 * 创建周报草稿
 */
@PostMapping
@Operation(summary = "创建周报草稿", description = "创建一份新的周报草稿，不会触发审核流程")
public ResponseEntity<ApiResponse<WeeklyReportResponse>> createDraft(
        @Valid @RequestBody WeeklyReportCreateRequest request) {
    WeeklyReportResponse response = weeklyReportService.createDraft(request);
    return ResponseEntity.ok(ApiResponse.success(response, "草稿已保存"));
}

/**
 * 更新周报草稿
 */
@PutMapping("/{id}/draft")
@Operation(summary = "更新周报草稿", description = "更新草稿内容，只能修改草稿状态的周报")
public ResponseEntity<ApiResponse<WeeklyReportResponse>> updateDraft(
        @PathVariable Long id,
        @Valid @RequestBody WeeklyReportUpdateRequest request) {
    WeeklyReportResponse response = weeklyReportService.updateDraft(id, request);
    return ResponseEntity.ok(ApiResponse.success(response, "草稿已更新"));
}

/**
 * 提交周报进行审核
 */
@PostMapping("/{id}/submit")
@Operation(summary = "提交周报审核", description = "提交草稿进行AI分析和人工审核")
public ResponseEntity<ApiResponse<WeeklyReportResponse>> submitForReview(
        @PathVariable Long id) {
    WeeklyReportResponse response = weeklyReportService.submitForReview(id);
    return ResponseEntity.ok(ApiResponse.success(response, "周报已提交审核"));
}

/**
 * 获取我的草稿列表
 */
@GetMapping("/my-drafts")
@Operation(summary = "获取我的草稿", description = "获取当前用户所有草稿状态的周报")
public ResponseEntity<ApiResponse<List<WeeklyReportListResponse>>> getMyDrafts() {
    User currentUser = getCurrentUser();
    List<WeeklyReport> drafts = weeklyReportRepository.findByUserIdAndEditStatus(
        currentUser.getId(), WeeklyReport.EditStatus.DRAFT
    );
    List<WeeklyReportListResponse> responses = drafts.stream()
        .map(this::convertToListResponse)
        .collect(Collectors.toList());
    return ResponseEntity.ok(ApiResponse.success(responses));
}

/**
 * 获取我的已提交周报
 */
@GetMapping("/my-submitted")
@Operation(summary = "获取我的已提交周报", description = "获取当前用户所有已提交的周报")
public ResponseEntity<ApiResponse<List<WeeklyReportListResponse>>> getMySubmitted() {
    User currentUser = getCurrentUser();
    List<WeeklyReport> submitted = weeklyReportRepository.findByUserIdAndEditStatus(
        currentUser.getId(), WeeklyReport.EditStatus.SUBMITTED
    );
    List<WeeklyReportListResponse> responses = submitted.stream()
        .map(this::convertToListResponse)
        .collect(Collectors.toList());
    return ResponseEntity.ok(ApiResponse.success(responses));
}

/**
 * 获取待审核周报列表（管理员）
 */
@GetMapping("/pending-review")
@Operation(summary = "获取待审核周报", description = "管理员获取所有待审核的周报")
@PreAuthorize("hasAnyRole('ADMIN', 'SUPER_ADMIN')")
public ResponseEntity<ApiResponse<List<WeeklyReportListResponse>>> getPendingReview() {
    List<WeeklyReport> pending = weeklyReportRepository.findByApprovalStatus(
        WeeklyReport.ApprovalStatus.PENDING_REVIEW
    );
    List<WeeklyReportListResponse> responses = pending.stream()
        .map(this::convertToListResponse)
        .collect(Collectors.toList());
    return ResponseEntity.ok(ApiResponse.success(responses));
}

/**
 * 管理员审核通过
 */
@PostMapping("/{id}/approve")
@Operation(summary = "审核通过", description = "管理员审核通过周报")
@PreAuthorize("hasAnyRole('ADMIN', 'SUPER_ADMIN')")
public ResponseEntity<ApiResponse<String>> approve(@PathVariable Long id) {
    User currentUser = getCurrentUser();
    weeklyReportService.adminApprove(id, currentUser.getId());
    return ResponseEntity.ok(ApiResponse.success("审核通过"));
}

/**
 * 管理员审核拒绝
 */
@PostMapping("/{id}/reject")
@Operation(summary = "审核拒绝", description = "管理员审核拒绝周报")
@PreAuthorize("hasAnyRole('ADMIN', 'SUPER_ADMIN')")
public ResponseEntity<ApiResponse<String>> reject(
        @PathVariable Long id,
        @RequestBody @Valid RejectRequest request) {
    User currentUser = getCurrentUser();
    weeklyReportService.adminReject(id, currentUser.getId(), request.getReason());
    return ResponseEntity.ok(ApiResponse.success("审核已拒绝"));
}

@Data
public static class RejectRequest {
    @NotBlank(message = "拒绝原因不能为空")
    private String reason;
}
```

---

## 7. Repository查询方法

```java
// WeeklyReportRepository.java

public interface WeeklyReportRepository extends JpaRepository<WeeklyReport, Long> {

    // ============= 草稿相关查询 =============

    /**
     * 查询用户的所有草稿
     */
    List<WeeklyReport> findByUserIdAndEditStatus(Long userId, WeeklyReport.EditStatus editStatus);

    /**
     * 查询用户的草稿数量
     */
    long countByUserIdAndEditStatus(Long userId, WeeklyReport.EditStatus editStatus);

    /**
     * 查询指定时间范围内的草稿（清理用）
     */
    List<WeeklyReport> findByEditStatusAndCreatedAtBefore(
        WeeklyReport.EditStatus editStatus,
        LocalDateTime before
    );

    // ============= 审核相关查询 =============

    /**
     * 查询所有待审核的周报
     */
    List<WeeklyReport> findByApprovalStatus(WeeklyReport.ApprovalStatus approvalStatus);

    /**
     * 查询指定审核人的待审核周报
     */
    @Query("SELECT wr FROM WeeklyReport wr " +
           "WHERE wr.approvalStatus = :status " +
           "ORDER BY wr.createdAt ASC")
    List<WeeklyReport> findPendingReviewReports(
        @Param("status") WeeklyReport.ApprovalStatus status
    );

    // ============= 处理状态查询 =============

    /**
     * 查询指定处理状态的周报
     */
    List<WeeklyReport> findByProcessingStatus(WeeklyReport.ProcessingStatus processingStatus);

    /**
     * 查询AI处理失败的周报（用于重试）
     */
    @Query("SELECT wr FROM WeeklyReport wr " +
           "WHERE wr.processingStatus = 'AI_FAILED' " +
           "AND wr.updatedAt > :since " +
           "ORDER BY wr.updatedAt DESC")
    List<WeeklyReport> findRecentAIFailedReports(@Param("since") LocalDateTime since);

    // ============= 悲观锁查询 =============

    /**
     * 悲观锁查询 - 防止并发修改
     */
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT wr FROM WeeklyReport wr WHERE wr.id = :id")
    Optional<WeeklyReport> findByIdForUpdate(@Param("id") Long id);

    // ============= 复合条件查询 =============

    /**
     * 组合查询：用户、编辑状态、时间范围
     */
    @Query("SELECT wr FROM WeeklyReport wr " +
           "WHERE wr.userId = :userId " +
           "AND wr.editStatus = :editStatus " +
           "AND wr.createdAt BETWEEN :startDate AND :endDate " +
           "ORDER BY wr.createdAt DESC")
    List<WeeklyReport> findByUserAndStatusAndDateRange(
        @Param("userId") Long userId,
        @Param("editStatus") WeeklyReport.EditStatus editStatus,
        @Param("startDate") LocalDateTime startDate,
        @Param("endDate") LocalDateTime endDate
    );

    /**
     * 统计查询：各状态的周报数量
     */
    @Query("SELECT wr.editStatus, COUNT(wr) FROM WeeklyReport wr " +
           "WHERE wr.userId = :userId " +
           "GROUP BY wr.editStatus")
    Map<WeeklyReport.EditStatus, Long> countByUserIdGroupByEditStatus(@Param("userId") Long userId);
}
```

---

## 8. 前端交互流程

### 8.1 用户创建和编辑流程

```typescript
// 前端页面流程

// 1. 用户创建周报
async function createWeeklyReport(reportData: WeeklyReportCreateRequest) {
    const response = await api.post('/weekly-reports', reportData);

    // 后端返回草稿状态的周报
    console.log(response.data.editStatus); // "DRAFT"

    showMessage('草稿已保存');
    router.push('/reports/my-drafts'); // 跳转到草稿列表
}

// 2. 用户编辑草稿
async function updateDraft(reportId: number, reportData: WeeklyReportUpdateRequest) {
    const response = await api.put(`/weekly-reports/${reportId}/draft`, reportData);

    showMessage('草稿已更新');
}

// 3. 用户提交审核
async function submitForReview(reportId: number) {
    const confirmed = await showConfirmDialog({
        title: '提交审核',
        message: '提交后将进行AI分析和管理员审核，期间无法编辑。确认提交吗？'
    });

    if (!confirmed) return;

    try {
        const response = await api.post(`/weekly-reports/${reportId}/submit`);

        showMessage('周报已提交，正在进行AI分析...');
        router.push('/reports/my-submitted');

        // 订阅WebSocket接收AI分析结果
        subscribeToAIAnalysisResult(reportId);

    } catch (error) {
        if (error.response?.status === 400) {
            showError(`内容不完整：${error.response.data.message}`);
        } else {
            showError('提交失败，请重试');
        }
    }
}

// 4. 监听AI分析结果
function subscribeToAIAnalysisResult(reportId: number) {
    const ws = new WebSocket(`/ws/weekly-report/${reportId}`);

    ws.onmessage = (event) => {
        const result = JSON.parse(event.data);

        if (result.type === 'AI_ANALYSIS_COMPLETED') {
            if (result.approvalStatus === 'PENDING_REVIEW') {
                showNotification('AI分析通过，已进入管理员审核');
            } else if (result.editStatus === 'DRAFT') {
                showNotification('AI分析置信度不足，请完善内容后重新提交', 'warning');
                router.push(`/reports/${reportId}/edit`);
            }
        }
    };
}
```

### 8.2 管理员审核流程

```typescript
// 管理员页面流程

// 1. 获取待审核列表
async function loadPendingReviews() {
    const response = await api.get('/weekly-reports/pending-review');
    const reports = response.data;

    // 显示待审核列表
    renderReviewQueue(reports);
}

// 2. 审核通过
async function approveReport(reportId: number) {
    const confirmed = await showConfirmDialog({
        title: '审核通过',
        message: '确认批准此周报吗？'
    });

    if (!confirmed) return;

    await api.post(`/weekly-reports/${reportId}/approve`);
    showMessage('审核通过');

    // 刷新列表
    loadPendingReviews();
}

// 3. 审核拒绝
async function rejectReport(reportId: number) {
    const reason = await showRejectDialog({
        title: '审核拒绝',
        message: '请输入拒绝原因：'
    });

    if (!reason) return;

    await api.post(`/weekly-reports/${reportId}/reject`, { reason });
    showMessage('已拒绝并通知作者修改');

    // 刷新列表
    loadPendingReviews();
}
```

---

## 9. 优势对比

### 9.1 新设计 vs 旧设计

| 维度 | 旧设计（混合状态） | 新设计（分层状态） |
|------|------------------|------------------|
| **状态清晰度** | ❌ AI_ANALYZING既是草稿又是处理状态，混乱 | ✅ 三层独立状态，各司其职 |
| **草稿功能** | ❌ 无真正草稿，创建即提交 | ✅ 独立草稿状态，允许反复编辑 |
| **资源消耗** | ❌ 未完成周报也触发AI分析 | ✅ 仅提交时触发，节省资源 |
| **用户体验** | ❌ 保存草稿立即收到拒绝通知 | ✅ 明确区分"保存"和"提交" |
| **查询逻辑** | ❌ 混乱的状态判断和查询条件 | ✅ 清晰的状态查询 |
| **扩展性** | ❌ 添加新状态会污染ApprovalStatus | ✅ 每层独立扩展，互不影响 |
| **语义准确** | ❌ ApprovalStatus包含非审核状态 | ✅ 每个枚举名副其实 |
| **业务一致** | ❌ isSubmitted()永远返回true | ✅ 真实反映提交状态 |

### 9.2 典型场景对比

**场景：用户想保存未完成的周报**

旧设计流程：
```
创建周报 → ApprovalStatus = AI_ANALYZING
→ 立即触发AI分析
→ 几秒后收到"置信度低，被拒绝"
→ 用户困惑："我还没写完啊！"
```

新设计流程：
```
创建周报 → EditStatus = DRAFT, ProcessingStatus = PENDING
→ 用户反复编辑保存
→ 用户点击"提交审核" → EditStatus = SUBMITTED, ProcessingStatus = AI_PROCESSING
→ AI分析 → 根据结果决定是否进入审核队列
→ 清晰明确的流程
```

---

## 10. 实施路径

### 10.1 分阶段实施

**阶段1: 数据库和实体层** (2天)
- 添加 `edit_status` 和 `processing_status` 字段
- 修改 `approval_status` 枚举值
- 数据迁移SQL
- 实体类修改
- 单元测试

**阶段2: Repository和Service层** (2天)
- 修改Repository查询方法
- 重写Service业务逻辑
- 分离创建草稿和提交审核逻辑
- 集成测试

**阶段3: Controller和API层** (1天)
- 修改Controller接口
- API文档更新
- 接口测试

**阶段4: 前端配合** (2天)
- 修改前端状态显示逻辑
- 添加"提交审核"按钮
- 草稿列表和已提交列表分离
- 端到端测试

**阶段5: 通知和监控** (1天)
- 调整通知逻辑
- 日志优化
- 监控告警规则更新

**总计: 8个工作日（1.5周）**

### 10.2 风险控制

**技术风险**:
- 数据迁移失败 → 提前备份，分批迁移，可回滚
- 状态转换逻辑错误 → 完善单元测试和集成测试

**业务风险**:
- 现有周报状态不一致 → 数据迁移脚本处理历史数据
- 用户习惯改变 → 前端提示用户新流程

**回滚策略**:
- 保留旧的 `approval_status` 值作为备份列
- 前端保留旧API兼容性（一周过渡期）
- 数据库迁移可逆（提供回滚SQL）

---

## 11. 总结

### 11.1 核心问题

**原有设计的根本错误**:
> 将"草稿状态"混入"审核状态"枚举中，违反了单一职责原则

### 11.2 正确的设计原则

1. **状态分层**: 编辑状态、处理状态、审核状态各自独立
2. **语义准确**: 枚举名称真实反映其管理的领域
3. **职责单一**: 每个状态枚举只负责一个维度
4. **流程清晰**: 用户操作与系统状态一一对应

### 11.3 核心改进点

| 改进项 | 改进措施 | 预期收益 |
|--------|---------|---------|
| 草稿独立 | 新增 EditStatus.DRAFT | 用户可反复编辑草稿 |
| 审核纯净 | ApprovalStatus 只包含审核状态 | 管理员查询清晰 |
| 处理可见 | 新增 ProcessingStatus | 系统监控和故障排查 |
| 延迟分析 | 提交时才触发AI | 节省30-50% AI调用 |
| 语义准确 | isDraft/isSubmitted真实反映状态 | 代码可读性提升 |

### 11.4 最终状态机

```
┌─────────────┐
│   创建周报   │
└──────┬──────┘
       │
       ▼
┌─────────────────────────┐
│  DRAFT (草稿状态)        │ ◄──┐
│  - 用户可编辑            │    │ 置信度不足
│  - 用户可删除            │    │ 或管理员拒绝
│  - 未触发AI分析          │    │
└──────┬──────────────────┘    │
       │ 用户点击"提交审核"      │
       ▼                        │
┌─────────────────────────┐    │
│  SUBMITTED + AI_PROCESSING│  │
│  - 锁定编辑              │    │
│  - AI分析中              │    │
└──────┬──────────────────┘    │
       │                        │
       ▼                        │
┌─────────────────────────┐    │
│  AI分析完成              │    │
└──────┬──────────────────┘    │
       │                        │
       ├─ 置信度 ≥ 70% ─────────┼─────┐
       │                        │     │
       └─ 置信度 < 70% ─────────┘     │
                                      ▼
                          ┌──────────────────────┐
                          │  PENDING_REVIEW       │
                          │  - 待管理员审核       │
                          └──────┬───────────────┘
                                 │
                                 ├─ 通过 ──► APPROVED (完成)
                                 │
                                 └─ 拒绝 ──► REJECTED (打回草稿)
```

---

**文档版本**: 2.0
**分析完成日期**: 2025-01-16
**相关文档**:
- `周报AI分析置信度问题分析_20250116.md`
- `周报AI分析置信度问题改进总结_20250116.md`
- `周报草稿状态分析_20250116.md` (已废弃，本文档替代)
